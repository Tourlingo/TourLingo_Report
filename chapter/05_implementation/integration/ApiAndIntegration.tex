\section{API and Integration}
\subsection{Introduction}

At the beginning of the project, when we formulated the product requirement document, it became clear that we won't be able to fulfil all of the requirements by developing the web app by only writing our own programs and creating our own services form scratch. For example, to provide the user with geographical and geolocation data, we would need to create and maintain a database and collect the data with the equipment that we neither financially not physically do not have access to. However, there are companies and service providers, that already provide this data either as a free or paid service. For this reason, we, as well as more than 80\% of other web developers, utilised a tool called an Application Programming Interface (API) \cite{what-is-an-api}. APIs allows developers to programmatically link the front-end with both internal back-end service, as well as external databases and servers. Specifically, we made heavy use of REST APIs, which is a specialised version of an API.

There are several key characteristics of RESTful APIs \cite{rest-api-introduction}. Firstly, the RESTful API requests are stateless, meaning that a previous request can't influence the data returned by the successive one.  This is useful for scaling the application, where more than one user independently is using the same service \cite{app-scaling}. Secondly, RESTful APIs are implemented in client-server fashion, meaning that the program that is requesting the information and the service providing it are fully separated and can be developed and maintained by entirely different teams. This allowed us to develop the front-end around the RESTful APIs' endpoints. Finally, RESTful APIs are implemented using uniform interface. More specifically, you would expect it to contain a URL path to send an HTTP request to, rely on standrat HTTP methods (GET, PUT, POST etc.), return the HTTP response code (200 OK for successful request or 404 Not Found for an endpoint leading to missing site), as well as to provide the data in JSON and/or XML data formats. 

[Since I provide code snippets with fetch api it may be worth it to explain them here. We'll see how it goes].

The rest of the chapter will be dedicated to describe what APIs we have chosen, how they work and how they fit into the front end of our web app. 


\subsection{Tools used to create the Cultural Tips page}

\subsubsection{How do we source the regional information?}

In the early stages of development, we were attempting to adopt web scraping from websites containing travel information, such as Wikivoyage (a Wikimedia Foundation's project, of which Wikipedia is the most famous one). The idea was to use the city name that the user is located in or planning to go to, and use it to retrieve the information from the web page describing the travel information of that city. This information would then be parsed, and the contents of each section (e.g. modes of transportation, etiquette, local festival locations etc.) would be displayed for the user to explore. However, the variation of the information format from city to city was too big for a standardised categorisation of information and its uniform presentation to be possible. Moreover, the client decided that the page would contain only the most essential information and that all the UI should fit on one page. Hence, we decided to adopt the use of a Large Language Model (LLM) to generate the data for us. Self-hosting an LLM requires computational power that our team did not possess \cite{selfHostedLLM}, especially taking into account the possibility of scaling. Therefore, we adopted OpenRouter API that handles communication with a range of free-to-use and paid LLM options, which leaves the choice to the client to scale the application after the project ends or not.  

When the user navigates to the Cultural Tips page, the following API call is made. 
\begin{minted}{js} 
  const response = await fetch(
    'https://openrouter.ai/api/v1/chat/completions',
    {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${process.env.NEXT_PUBLIC_OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'mistralai/mistral-7b-instruct:free',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt },
        ],
      }),
    }
  );
\end{minted}
Importantly, OpenRouter implements OpenAI API specification for /completions and /chat/completions endpoints \cite{noauthor_openrouter_nodate}. Therefore, we can use OpenAI API terminology \cite{openAI_explanation_onHowToUseTheirApi} to shape the reply we get from the LLM of choice regardless of what the LLM was chosen. To instruct the LLM to provide us with the response that we can automatically parse through, the messages array contains an object { role: 'system', content: systemPrompt }. systemPrompt variable is a string that 
\begin{enumerate} \itemsep0pt \parskip0pt
    \item explains what role the LLM should take
    \item what format of data use program expects to receive
    \item what shape the resulting JSON file should be in
    \item how many values should each entry contain
    \item what to do in case the information does not exist or is not retrievable.
\end{enumerate}
Conversely, in the { role: 'user', content: userPrompt } the userPrompt variable is a simple string "Generate JSON for \$\{city\}", where the city variable is a Zustand (global) variable created when the user provides their location in the map page. 

Although we have included strict format rules in the system prompt to the LLM, the received data still had to be checked for adherence to the format. After the format of the data is verified, a backend API call is made (see section 5.2.11 to see how the data is translated):
\begin{minted}{js} 
fetch(process.env.TRANSLATION_API_URL, {
    method: 'POST',
    body: JSON.stringify(verifiedRequestBody),
    headers: {
      'Content-type': 'application/json',
    },
})
\end{minted}
where the process.env.TRANSLATION\_API\_URL is the endpoint of our backend and verifiedRequestBody is a variable that contains the object with has been properly formatted. When the API call is resolved, the data is once again verified using the same checker as before. Finally, it is returned to the page.tsx, where it is parsed through and displayed to the user. 


\subsection{Tools used to create the Map page}

\subsubsection{Creating an interactive map: Leaflet}

Leaflet is an open source JavaScript library, that provides a broad range of tools to integrate and customise an interactive map into your front-end project \cite{leafletMainPage}. While Leaflet was main for vanilla js, React Leaflet tailors the functions of the original Leaflet to be used as props in a React project, which is more suitable for our needs. (TBF this is the most I understood from reading around the topic. If someone wants to jump into the explanation how react leaflet works from React standpoint, feel free to do so)

2) Explain how our code works
- <MapContainer> prop creates the window with the rendered map itself.
- <TileLayer> prop is the one that actually imports the visual map tiles. Since have chosen the Open Street Map as a provider of geographical and locational data, we chose to utilise the interactive map from the service as well:
\begin{minted}{HTML}
<TileLayer
    attribution='&copy; 
        <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> 
        contributors'
    url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
/>
\end{minted}
The advantage of this choice lies in the fact the the image of the map that is displayed on the screen is built on the geolocation data that OSM posesses. That means that when we query some data from the OSM database with the intent to then display/overlay it on the map, the mapping of the representation (pins) of the queried data is going to be extremely precise. On the other side, because OSM provides raster tiles (i.e prerendered PNG images of the map), extracting the names of the objects on the map, translating them and putting them back on the map essentially is impossible. It is possible to overlay the translations of the points of interest on the map, but that makes the map interface too cluttered and unappealing.

The overlaying of the desired data was done with the <Marker> prop. For example, the following code uses the information from the JSON file that was retireved with the Overpass API and converts it into the graphical information in the form of pins on the map:
\begin{minted}{HTML}
  {pins.map((pin) => (
    <Marker
      key={pin.id}
      position={[pin.lat, pin.lon]}
      icon={createSVGPin(pin.icon)}
      eventHandlers={{
        click: () => onPinClick?.(pin),
      }}
    >
      <Popup>
        <div className="p-2 leading-relaxed">
          <h3 className="font-bold text-lg mb-2 text-gray-800">
            {pin.title}
          </h3>
          <p className="text-xs text-gray-500 mb-1">{pin.category}</p>
          <p className="text-xs mb-2 leading-tight text-gray-700">
            {pin.description}
          </p>
          {pin.street && (
            <p className="text-xs text-gray-500 leading-tight mb-1">
              Street: {pin.street}
            </p>
          )}
          {pin.postcode && (
            <p className="text-xs text-gray-500 leading-tight">
              Postcode: {pin.postcode}
            </p>
          )}
        </div>
      </Popup>
    </Marker>
  ))}
\end{minted}
In this example the "pins" array of objects was created after parcing though the OSM JSON file and destructuring the useful information (e.g. entry name, address, coordinates etc.). This information is displayed to the user upon click on the pin, for which the markers <Popup> prop is responsible. 

\subsubsection{Creating Points of interes (POI): Open Street Map (OSM) and Overpass}

Two major external services that we use to provide the use with navigational information are OSM and Overpass. OSM is an online and open source geographical database. The contents of the database are maintained by a community of enthusiasts and are freely accessible by everyone. However,  since the OSM does not provide a programming interface to interact with the database, our team has adopted Overpass API to solve the problem. It provides 2 types of tools that make interaction with the database possible. The first one is the interpreter that accepts the HTTP requests, and returns OSM database entries. The API supports the retrieval of OSM data in JSON format, which was handled by the Fetch API, a build in Javascript API that handles RESTful API requests. The second tool of Overpass API is the query language, that allows for the selection of only those OSM database entries that have characteristics and format of interest. The most used feature of the query language was the selection of OSM nodes based on the tags, which explain the nature of the object. 

When the user navigates to the map page and gives permission for their location information to be collected, an Overpass API call is made.
\begin{minted}{js} 
fetch('https://overpass-api.de/api/interpreter', {
    method: 'POST',
    body: `
            [out:json][timeout:25];
            "node selection expression";
            out center 50;
          `,
});
\end{minted}
Here, the 'https://overpass-api.de/api/interpreter' is the endpoint to the interpreter \cite{OverpassAPIDocsWiki}; "POST" method was used to allow the inclusion of the body to the server, and the "body" contains the Overpass QL query (see \cite{OverpassAPIQueryLanguageGuide} for full QL guide). This query entails the following: retrieve a JSON file with a 25 timeout; the file should contain selected nodes of interest; each node must have a center coordinate that would used to overlay it on the map; and the JSON file should have at most 50 nodes. The node selection expression is composed of the following repeated statement: "(nodeOfInterest1(bbox); nodeOfInterest2(bbox); ... nodeOfInterestN(bbox);)", which by the Overpass is interpreted as "go through all of the nodes within the bounding box and retrieve the nodes of interest 1 or the the nodes of interest 2 etc.". The bounding box is a rectangular area of the map that is visible to the user. It is represented by 2 pairs of coordinates: the latitude and longitude of the bottom left corner of the visible map, and that of upper right one. 

The nodes of interest in actuality are represented in the following format: 'node["tag"="tag's value"]'. Node is one of 3 basic OSM data types (alongside ways and relations), and it represents the most basic geolocational object in the OSM database. Each data type in OSM has the following keys: "type", "id" (the serial number of the data entry), "latitude", "longitude" and "tags" (optional, but always present in the response because we query for them). The query language also supports regular expressions, so the query "shop"~"supermarket|convenience|greengrocer" would select nodes referencing supermarkets, convenience stores and greengrocer stores. 

The received JSON file is then parsed, and the extracted data is used to create the POI pins overlaid on the map and to fill up the POI cards in the Essential and Recommendations overlay sections.

\subsubsection{Forward and reverse geocoding: Nomitam API}

Forward geocoding (or simply geocoding) is a process of conversion of a human readable address into a latitude and longitude of the physical object \cite{forwardAndReverseGeocoding}. Hence, reverse geocoding is a process of retrieval of the most appropriate address from the provided coordinates. Both services are standard means to interact with an online map, and there is a number of providers of the geocoding service. Considering our budget limitations and high reliance on OSM, we chose Nomitam API as a provider, as it has an unlimited free plan. It also includes high integration with OSM data, which makes overaly of data onto our map extremely accurate. Despite the drawback of Nomitam (low volume of requests and no support for high traffic applications) for the purposes small scale development we considered it to be the perfect tool. 

\paragraph{Reverse geocoding}
In our application we use both forward and reverse geocoding. When the user navigates to the map page, the geolocation of the device of the user is collected, following permission from the user. The collection is handled by the \mintinline{js}{getCurrentPosition()} method of the Geolocation interface, which belongs to the Document Object Model (DOM) API. Once the coordinated are collected, an Nomitam API call for reverse geocoding is made with said coordinates:
\begin{minted}{js}
const res = await fetch(
  `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`
);
\end{minted}
Following the parsing of the response of we extract the name of the city and the country that the user is in. This data is then set as a global variable using Zustand library and used, for instance, for generation of a cultural tip by the LLM.

\paragraph{Forward geocoding}
The forward geocoding is implemented in the map page's Search bar. When the user decides to enter any text into the searchbar, the following code is executed:
\begin{minted}{js}
  const res = await fetch(
    `https://nominatim.openstreetmap.org/
    search?q=${encodeURIComponent(searchText)}&format=json`,
    { signal: controller.signal,}
  );
\end{minted}
where "controller" is an AbortController() instance used to shut show the reqest if the need be; and the "searchText" corresponds to the submitted destination from the search bar. 

\section{Deployment of the front end}
\subsection{Drafting notes}
What might I include here?
\begin{itemize}
    \item What is the purpose
    \item What did I have
    \begin{itemize}
        \item Pros and cons of each option
        \item What did I ended up seetling up with
    \end{itemize}
\end{itemize}
