\section{API and Integration}
\subsection{Introduction}

At the beginning of the project, when we formulated the product requirement document, it became clear that we will not be able to fulfil all of the requirements by developing the web app only by writing our own programmes and creating our own services from scratch. For example, to provide the user with geographical and geolocation data, we would need to create and maintain a database and collect the data with the equipment to which we have neither financial nor physical access. However, there are companies and service providers, that already provide this data either as a free or paid service. For this reason, we, as well as more than 80\% of other web developers, utilised a tool called an Application Programming Interface (API) \cite{what-is-an-api}. APIs allows developers to programmatically link the front-end with both internal back-end service, as well as external databases and servers. Specifically, we made heavy use of REST APIs, which is a specialised version of an API.

There are several key characteristics of RESTful APIs \cite{rest-api-introduction}. Firstly, the RESTful API requests are stateless, meaning that a previous request can't influence the data returned by the successive one. This is useful for scaling the application, where more than one user independently uses the same service \cite{app-scaling}. Secondly, RESTful APIs are implemented in a client-server fashion, meaning that the program that requests the information and the service that provides it are fully separated and can be developed and maintained by entirely different teams. This allowed us to develop the front-end around the RESTful API endpoints. Finally, RESTful APIs are implemented using uniform interface. More specifically, it is expected to contain a URL path to send an HTTP request to, to rely on standard HTTP methods (GET, PUT, POST etc.), to return the HTTP response code (200 OK for successful request or 404 Not Found for an endpoint leading to missing site), as well as to provide the data in JSON and/or XML data formats. 

The rest of the chapter will be dedicated to describe what APIs we have chosen, how they work and how they fit into the front end of our web app. 


\subsection{Tools used to create the Cultural Tips page}

\subsubsection{How do we source the regional information?}

In the early stages of development, we were attempting to adopt web scraping from websites containing travel information, such as Wikivoyage (a Wikimedia Foundation's project, of which Wikipedia is the most famous one). The idea was to take the city name that the user is located in or planning to go to, and use it to retrieve the information from the web page describing the travel information of that city. This information would then be parsed, and the contents of each section (e.g. modes of transportation, etiquette, local festival locations etc.) would be displayed for the user to explore. However, the variation of the information format from city to city was too big for a standardised categorisation of information and its uniform presentation to be possible. Additionally, not all cities had enough information to fill all of the important sections. Ultimately, the client decided that the page should contain only the most essential information and that all the UI should fit on one page. Hence, we decided to adopt the use of a Large Language Model (LLM) to generate the data for us. Self-hosting an LLM requires computational power that our team did not possess \cite{selfHostedLLM}, especially taking into account the possibility of scaling. Therefore, we adopted OpenRouter API that handles communication with a range of free-to-use and paid LLM options, which leaves the to the client the choice of scaling the application after the project ends.

An important feature of the OpenRouter API when it comes to utilisation is that it implements OpenAI API specification for /completions and /chat/completions endpoints \cite{noauthor_openrouter_nodate}. Therefore, we can use OpenAI API terminology \cite{openAI_explanation_onHowToUseTheirApi} to shape the reply we get from the LLM of choice regardless of what the LLM was chosen. When the user navigates to the Cultural Tips page, a POST request is made to the "https://openrouter.ai /api/v1/chat/completions" endpoint. The body of the request contains a "model" key that specifies the LLM model we with to use and the "messages" key that specifies the LLM query. To instruct the LLM to provide us with the response that we can automatically parse through, the messages array contains an object { role: 'system', content: systemPrompt }. systemPrompt variable is a string that 
\begin{enumerate} \itemsep0pt \parskip0pt
    \item explains what role the LLM should take
    \item what format of data use program expects to receive
    \item what shape the resulting JSON file should be in
    \item how many values should each entry contain
    \item what to do in case the information does not exist or is not retrievable.
\end{enumerate}
Conversely, in the { role: 'user', content: userPrompt } the userPrompt variable is a simple string "Generate JSON for a city", where the city variable is a Zustand (global) variable created when the user provides their location on the map page. 

Although we have included strict format rules in the system prompt to the LLM, the received data still had to be checked for adherence to the format. After the format of the data is verified, a backend API call is made (go to \autoref{sec:backend} to see how the data is translated). It is a POST request, where the endpoint to the backend is "https://f1a8774f4315.ngrok-free.app/api/translate/cultural-tips", and the body of the post request is object with the LLM text that has been properly formatted. When the API call is resolved, the data is once again verified using the same checker function. Finally, it is returned to the page.tsx, where it is parsed and displayed to the user.


\subsection{Tools used to create the Map page}

\subsubsection{Creating an interactive map: Leaflet}

Leaflet is an open source JavaScript library, that provides a wide range of tools to integrate and customise an interactive map into your front-end project \cite{leafletMainPage}. Leaflet is primarily designed for vanilla JavaScript, and the toolset is designed to program the map elements in an imperative way \cite{LeafletImperative}. This means that you as a programmer are responsible for manually building each element step by step, which is great for customisability, but detrimental for code readability, maintainability and general speed of development. Which is why the interactive map elements are build with React-leaflet. This is a declarative React API, which means that instead of creating and assembling map objects manually, we import map-related props and let React handle the DOM \cite{LeafletDeclarative}.

The main prop that sets the window for the map is <MapContainer>, where "\lstinline|style={{height:'100vh', width:'100%'}}|" parameter sets the window to take the entire screen height, and because the screen width changes depending on the presence of the Recommendation or Essentials overlay, the width was set to 100\% of the width of the parent div. The <TileLayer> prop imports the visual map tiles. Since we have chosen the Open Street Map as a provider of geographical and locational data, we chose to utilise the interactive map from the service as well (url="\lstinline|https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png|"). Therefore, when we query OSM data which we would then display/overlay it on the tiles, the mapping of the representation (pins) of the queried data is going to be extremely precise. On the other side, because OSM provides raster tiles (i.e prerendered PNG images of the map), extracting the names of the objects on the map, translating and putting them back on the map would not be feasible. It is possible to overlay the translations of the points of interest on the map, but that makes the map interface too cluttered and unappealing. The overlaying of the POI data was done with the <Marker> prop. When the list of pin objects is created, for each of them a marker prop is created, with the marker props containing the position (latitude and longitude), the icon (a tailored SVG image) and an event handler that on click shows the contents of the <Popup> prop. It contains detailed information about object represented by the pin.

\subsubsection{Creating Points of interest (POI): OSM and Overpass}

Two major external services that we use to provide the user with navigational information are OSM and Overpass. OSM is an online open source geographical database. The contents of the database are maintained by a community of enthusiasts and are freely accessible by everyone. However, since the OSM does not provide a programming interface to interact with the database, our team has adopted Overpass API. It provides 2 types of tools that make interaction with the database possible. The first one is the interpreter that accepts the HTTP requests, and returns OSM database entries, with a possibility to configure the data in a JSON format. The second tool is the query language, that allows for the selection of only those OSM database entries that have characteristics and format of interest. The most used feature of the query language was the selection of OSM nodes based on the tags, which explain the nature of the object. 

When the user navigates to the map page and gives permission for their location information to be collected, a POST request to the interpreter endpoint ("https://overpass-api.de/api/interpreter") \cite{OverpassAPIDocsWiki} is made. The body of the POST request contains the Overpass QL query (see \cite{OverpassAPIQueryLanguageGuide} for a full QL guide). The node selection expression, which is contained within the query, is composed of the following repeated statement: "(nodeOfInterest1(bbox); nodeOfInterest2(bbox); ... nodeOfInterestN(bbox);)", which by the Overpass is interpreted as "go through all of the nodes within the bounding box and retrieve the nodes of interest 1 or the nodes of interest 2 etc.". The bounding box is a rectangular area of the map that is visible to the user. It is represented by 2 pairs of coordinates: the latitude and longitude of the bottom left corner of the visible map, and that of the upper right one. The node of interest section is implemented in the form 'node["tag"="tag's value"]', where the tag describes a category of an object (e.g. a ship), and the tag's value provides further specialisation (e.g. music, games or groceries). For a complete list of possible tags, view OSM Maps features \cite{OSM_map_features}. The received JSON file is then parsed, and the extracted data is used to create the POI pins overlaid on the map and to fill up the POI cards in the Essential and Recommendations overlay sections.

\subsubsection{Forward and reverse geocoding: Nomitam API}

Forward geocoding (or simply geocoding) is a process of conversion of a human readable address into a latitude and longitude of the physical object \cite{forwardAndReverseGeocoding}. Hence, reverse geocoding is a process of retrieval of the most appropriate address from the provided coordinates. Both services are standard means of iteration with an online map, and there are a number of providers of the geocoding service. Considering our budget limitations and high reliance on OSM, we chose Nomitam API as a provider, as it has an unlimited free plan. It also includes high integration with OSM data, which makes overlay of data onto our map extremely accurate. Despite the drawback of Nomitam (low volume of requests and no support for high traffic applications), we considered it to be the perfect tool for our purpose of a small scale development. 

\paragraph{Reverse geocoding}
In our application we use both forward and reverse geocoding. When the user navigates to the map page, the user can opt in to provide the application their location. If the permission is granted, the user’s coordinates are obtained via the browser’s Geolocation API, and a GET request for reverse geocoding is made to the following endpoint "\lstinline|https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}|". Since this is a GET request, it does not have a request body. Therefore, the latitude and longitude are appended to the endpoint as a query string. Following the parsing of the response, we extract the name of the city and the country of interest. This data is then set as a global variable using Zustand library and used, for instance, for generation of a cultural tip by the LLM.

\paragraph{Forward geocoding}
The forward geocoding is implemented in the map page's Search bar. When the user decides to enter any text into the searchbar, a GET get request is made to the following endpoint "\lstinline|https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(searchText)}&format=json|". The "searchText" variable contains the destination city. This request is then processed by Nomitam, and an array of objects is returned, where the names of the object are the contain the closest match to the inserted text. As this is forward geocoding, each returned object contains latitude and longitude, that are extracted and used to set up the new bounding box, if the user want to move the map view to the requested location.

