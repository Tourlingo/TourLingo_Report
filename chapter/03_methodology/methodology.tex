
\chapter{Methodology}
\section{Software Development Techniques}
Our project began with a comprehensive requirements gathering phase where we collaborated closely with the client to define the project's scope. We established a set of core features for a Minimum Viable Product (MVP), which was formally documented and approved. This clear initial plan allowed us to structure the project efficiently while also outlining a roadmap for future enhancements. A key objective was to minimize dependencies among team members. To achieve this, we created a well-structured Product Requirements Document (PRD) that enabled each team member to work on different components independently, fostering a parallel development process and ensuring a clear understanding of individual responsibilities.

Given our need for flexibility and continuous client engagement, we adopted the Agile methodology as our primary project management framework. This approach allowed us to break down the project into manageable iterations, or sprints, rather than adhering to a rigid, linear timeline. To facilitate this, we leveraged Jira, a powerful project management tool. Jira enabled us to create and assign tasks, manage our sprints, and conduct thorough sprint reviews. This process provided our team with clear visibility into the development pipeline and ensured that we were consistently delivering value. Furthermore, we integrated a Continuous Integration and Continuous Deployment (CICD) pipeline. This allowed us to automate the building, testing, and deployment of our code, ensuring that new features and bug fixes could be released efficiently and reliably. This combination of an Agile workflow, supported by Jira and automated through CICD, allowed us to maintain a dynamic and responsive development process that could quickly adapt to new requirements and feedback.

Our team operated with an independent, decentralized structure where each member took ownership of their assigned tasks. To manage this workflow, we used Jira as our central hub for tracking all project tickets, maintaining the product backlog, and organizing our sprints. This platform provided a transparent view of our progress and allowed us to manage our workload effectively. Our team maintained a consistent communication cadence with weekly meetings every Monday to review sprint progress, address any roadblocks, and plan the upcoming week's tasks. Furthermore, we held meetings with the client every Friday, which served as dedicated sessions for feature demos, gathering feedback, and addressing any questions or new requests. To tackle complex tickets that required collaborative effort, we also adopted pair programming on other weekdays. This practice not only facilitated the resolution of challenging technical issues but also promoted knowledge sharing and code quality across the team.

\section{Backend Tools and Services}
The backend for the project, a Multilingual Virtual Tour Assistant for Local Navigation (MTAP), is a microservices-based system designed for scalability and robustness. Built primarily with Java 17/21 and the Spring Boot 3.0+ framework, the architecture emphasizes loose coupling and domain-driven design. The system is comprised of several key services, including an API Gateway to handle routing and security, and dedicated services for Authentication, User management, Location-based data, Translation, Navigation, and Content management. The project uses PostgreSQL for its primary database, Redis for caching, and Elasticsearch for efficient searching of points of interest. Continuous integration and deployment are managed through GitHub Actions, while monitoring is handled by Prometheus and Grafana. This combination of technologies and architectural patterns ensures the backend is both highly performant and easy to maintain.
    
\section{Frontend Tools and Services}
The frontend was built with a modern and scalable technology stack. Next.js was used as the primary framework, built on top of React, with TypeScript for strong typing. For styling and design, the team implemented Tailwind CSS with a custom theme. 
React Context API was chosen for managing global state, such as user preferences and language settings, while React Query was utilized for handling server-side data, including caching and synchronization. For authentication, the project used NextAuth.js. The multilingual functionality was powered by next-i18next. The application integrates with several backend services using an Axios-based API client. These services include a User Service for profile management, a Location Service for nearby points of interest and navigation, and a Translation Service for dynamic content. For mapping, the project initially used Leaflet.js with OpenStreetMap. The codebase is organized according to atomic design principles, with components categorized as atoms, molecules, organisms, and templates to ensure a modular and maintainable structure.

\section{Qualitative Evaluation Techniques}
        \blindtext

\section{Git Branching Strategies}
        \blindtext